using Acme.ProductSelling.Orders.Dtos;
using Acme.ProductSelling.Payments;
using Riok.Mapperly.Abstractions;
using System;
using Volo.Abp.Mapperly;

namespace Acme.ProductSelling.Orders;

[Mapper(RequiredMappingStrategy = RequiredMappingStrategy.Target)]
[MapExtraProperties]
public partial class OrderToOrderDtoMapper : MapperBase<Order, OrderDto>
{
    [MapperIgnoreTarget(nameof(OrderDto.OrderStatusText))]
    [MapperIgnoreTarget(nameof(OrderDto.PaymentStatusText))]
    [MapperIgnoreTarget(nameof(OrderDto.StoreName))]
    public override partial OrderDto Map(Order source);

    [MapperIgnoreTarget(nameof(OrderDto.OrderStatusText))]
    [MapperIgnoreTarget(nameof(OrderDto.PaymentStatusText))]
    [MapperIgnoreTarget(nameof(OrderDto.StoreName))]
    public override partial void Map(Order source, OrderDto destination);

    public override void AfterMap(Order source, OrderDto destination)
    {
        destination.OrderStatusText = source.OrderStatus.ToString();
        destination.PaymentStatusText = source.PaymentStatus.ToString();
    }
}

[Mapper(RequiredMappingStrategy = RequiredMappingStrategy.Target)]
public partial class CreateOrderDtoToOrderMapper : MapperBase<CreateOrderDto, Order>
{
    public override Order Map(CreateOrderDto source)
    {
        // Note: Creating an Order strictly from DTO in mapper is tricky because 
        // OrderNumber should typically be generated by a Domain Service.
        // We act as a factory here with temporary/default values where necessary.

        var entity = new Order(
            Guid.NewGuid(),
            string.Empty, // OrderNumber - Caller must likely set this later or via Domain Service
            DateTime.Now, // OrderDate
            null,         // CustomerId
            source.CustomerName,
            source.CustomerPhone,
            source.ShippingAddress,
            source.PaymentMethod
        );

        // Handle specific Enum mapping if needed manually, or let Update map do it
        if (source.OrderType.HasValue)
        {
            // If entity allows public setting of this property
            entity.SetStoreInfo(Guid.Empty, source.OrderType.Value);
        }

        Map(source, entity);

        return entity;
    }
    [MapperIgnoreTarget(nameof(Order.Id))]
    [MapperIgnoreTarget(nameof(Order.OrderNumber))] // Protected set
    [MapperIgnoreTarget(nameof(Order.OrderDate))]   // Protected set
    [MapperIgnoreTarget(nameof(Order.CustomerId))]  // Protected set
    [MapperIgnoreTarget(nameof(Order.OrderItems))]  // Navigation property collection, usually manually mapped
    [MapperIgnoreTarget(nameof(Order.TotalAmount))]
    [MapperIgnoreTarget(nameof(Order.OrderHistories))]
    [MapperIgnoreTarget(nameof(Order.SellerId))]
    [MapperIgnoreTarget(nameof(Order.SellerName))]
    [MapperIgnoreTarget(nameof(Order.CashierId))]
    [MapperIgnoreTarget(nameof(Order.CashierName))]
    [MapperIgnoreTarget(nameof(Order.FulfillerId))]
    [MapperIgnoreTarget(nameof(Order.FulfillerName))]
    [MapperIgnoreTarget(nameof(Order.CompletedAt))]
    [MapperIgnoreTarget(nameof(Order.FulfilledAt))]
    [MapperIgnoreTarget(nameof(Order.StoreId))]
    [MapperIgnoreTarget(nameof(Order.OrderType))]
    public override partial void Map(CreateOrderDto source, Order destination);
}
[Mapper(RequiredMappingStrategy = RequiredMappingStrategy.Target)]
public partial class OrderHistoryToOrderHistoryDtoMapper : MapperBase<OrderHistory, OrderHistoryDto>
{
    // Auto convert enums to string if name matches and types differ? 
    // Mapperly does strictly type safe. Need AfterMap for Enum->String unless naming convention allows.
    // Assuming simple mapping for now.
    public override partial OrderHistoryDto Map(OrderHistory source);
    public override partial void Map(OrderHistory source, OrderHistoryDto destination);

    // Assuming string properties in DTO match Enums in Entity, manual map might be needed
    // if types differ (Enum vs String). 
    private string MapStatus(OrderStatus status) => status.ToString();
    private string MapPayStatus(PaymentStatus status) => status.ToString();
}